package io.mrlokop.kotlin.utils.conventer

import com.google.gson.Gson
import io.mrlokop.kotlin.utils.conventer.enities.EntryEntity
import io.mrlokop.kotlin.utils.conventer.enities.IntPrimitiveEntity
import io.mrlokop.kotlin.utils.conventer.enities.TypeEntity
import io.mrlokop.kotlin.utils.conventer.enities.expression.*

class JSConverter(val entries: List<EntryEntity>) {
    fun convert(): String {
        //language=JavaScript
        var script = "\n///\n"
        script += "///\tAutogenerated by KConvertLib\n"
        script += "///\t\tAuthor: vk.com/themrlokopoff\n"
        script += "///\n"
        script += "\n"
        //language=JavaScript
        script += """
            const root = {};
            const ${escapePackage("converter")} = (() => {
                function escapePackage(pck) {
                    return "${'$'}_" + pck.replace(/\./gm, "_")              
                }
                
                function getPackage(key) {
                    let a = root;
                    for (const k of key.split(".")) {
                        const p = a;
                        a = a[k] || {};
                        p[k] = a;
                    }            
                    return a;
                }
                const converterPackage =  getPackage("converter")
                converterPackage.getPackage = getPackage;
                converterPackage.escapePackage = escapePackage;
                return converterPackage;
            })();

        """.trimIndent()
        entries.forEach { entry ->

            script += """
                (() => {
                /* -> AUTOGENERATED ENTRY <- */
                /*    -> PACKAGE INFO <- */
                /* Package: ${entry.packageName} */
                /* File name: ${entry.fileName} */
                
            """
            val packageName = escapePackage(entry.packageName)

            //language=JavaScript
            if (packageName == "\$"){

                script += """
                const $packageName = root

            """.trimIndent()
            }else {
                script += """
                const $packageName = ${escapePackage("converter")}.getPackage("${entry.packageName}")

            """.trimIndent()
            }

            entry.topLevels.forEach {
                it.declarations.forEach {
                    it.fields.forEach {
                        if (it.expression != null) {
                            script += """
                $packageName['${it.name}'] = ${wrap(it.expression!!)};
            """.trimIndent()

                        }
                    }
                    it.functions.forEach {
                        val funcName = packageName + "_" + it.name
                        script += """
                            function $funcName(${'$'}__args) {
                                ${
                        it.body.block.statements.map {
                            return@map it.expressions.map {
                                wrap(it)
                            }.joinToString(";\n")
                        }.joinToString(";\n")
                        }
                            }
                            $funcName.${'$'} = {
                                _meta: {
                                    mods: ${Gson().toJson(it.mods)},
                                    package: $packageName,
                                    packageName: '${entry.packageName}',
                                    parameters: [
                                        ${it.params.map {
                            return@map """
                                {
                                    name: "${it.name}",
                                    type: ${serialize(it.type!!)}
                                }
                            """.trimIndent()
                        }.joinToString(",\n")}
                                    ]
                                }
                            }
                            $packageName['${it.name}'] = $funcName;
                            
            """.trimIndent()


                    }
                }
            }

            script += """
                })();
            """
        }
        script =
            "exports = () => {\n" +
                    script.replace("\n", "\n\t") +
                    """
                        (() => {
                            function recursive(data) {
                        for (const key of Object.keys(data)) {
                        const v = data[key];
                        
                                                        if (typeof v === 'object') {
    recursive(v)                                                        
                                                        }
                                                        if (typeof v === 'function') {
if (key === "main") {
                                                        v()
                                                        }
                                                        
                                                        }
                                                        }
                            }
                            recursive(root)
                        })()
                        return root;
                        }
                        console.log(exports())
                    """.trimIndent()
        //"\n\n\n\treturn root\n}\n\nconsole.log(\"Compiled: \", exports())"


        return script
    }

    fun escapePackage(pck: String): String {
        if (pck.isEmpty())
            return "\$"
        return "\$_" + pck.replace(".", "_")
    }

    fun serialize(data: Any): String {
        if (data is TypeEntity) {
            if (data.subTypes.isEmpty()) {
                return "{\n\"name\": '${data.name}'\n}"
            } else {
                return "{\n\"name\": '${data.name}', \nsubTypes: [\n${data.subTypes.map { 
                    return@map serialize(it)
                }.joinToString(", ")}\n]\n}"
            }
        }
        return "/*Serialization failed: ${data.javaClass.name}*/"
    }

    fun wrap(expression: ExpressionEntity): String {

        if (expression is FunctionExpression) {

            var str =
                (if (expression.member.isNotEmpty()) (expression.member + ".") else "") + expression.functionName + "(...["
            expression.args.forEach {
                str += "\n${wrap(it)},"
            }
            str += "\n])"
            return str

        }
        if (expression is DeclarationExpression) {
            var a = ""
            if (expression.field.decType == "val")
                a = "const "
            else
                a = "var "
            a += expression.field.name + " = " + wrap(expression.field.expression!!)
            return a
        }
        if (expression is ConstantExpression) {
            if (expression.const is IntPrimitiveEntity) {
                return "${(expression.const as IntPrimitiveEntity).get()}"
            }
        }
        if (expression is MultiplicativeExpression) {

            var script = " "
            expression.operations.forEach {
                if (it is MultiplicativeData) {
                    script += " (${wrap(it.data)}) "
                }
                if (it is MultiplicativeOperator) {
                    script += it.data
                }
            }
            script += " "
            return script
        }
        if (expression is AdditiveExpression) {
            var script = " "
            expression.operations.forEach {
                if (it is AdditiveData) {
                    script += " (${wrap(it.data)}) "
                }
                if (it is AdditiveOperator) {
                    script += it.data
                }
            }
            script += " "
            return script
        }
        if (expression is StringExpression) {
            return "'${expression.get()}'"
        }
        if (expression is IdentifierExpression) {
            return expression.identifier
        }
        if (expression.javaClass.name == "io.mrlokop.kotlin.utils.conventer.enities.expression.ExpressionEntity") {
            return ""
        }
        return "/*Wrapping failed: ${expression.javaClass.name}*/"
    }
}
